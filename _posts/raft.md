# 重新理解Raft共识协议

分布式系统领域近几年有一些非常火的名词，比如去中心化，分布式共识，强一致性，CAP，拜占庭容错等等。网络上有不少关于这些内容的解读，但是大多数文章与视频要么浮于表面，读完之后似懂非懂，要么只强调某个协议或技术本身，管中窥豹。这个系列的文章，就是希望厘清分布式系统理论与设计之间的关系，帮助大家更好的理解分布式系统。

本文为这个系列第一篇，主要是解释Raft协议这个共识协议(Consensus protocol)在干啥，顺便解决一些网上常见的误解。Raft这几年在工业界非常出名，很多保证强一致性的组件都用到了Raft，如etcd。然而，强一致性这个词到底代表什么，它指的是数据一致吗，其实很多文章也没有说。其实，Raft所属的共识协议领域并不讨论强一致性，而强一致性这个词在分布式系统中也有专门的解释。所以，聊etcd这样的组件，或者聊一致性这个概念，并不能讲清楚Raft是在做啥。

现在先给结论，Raft是一个宕机容错协议(crash fault tolerant protocol, CFT)，它借助一个相对稳定的中心节点，拓展了单槽位共识。这里虽然出现了较多的特殊名词，但是请读者们先记住上面对Raft所作的定义。相信当你看完全文后，会对上面这句话有更深的认识。首先，让我们来对“共识”这个概念做一些直观的认识。


## 0. 用例子来介绍我们关心的问题


我们要先熟悉一个概念，叫做“达成统一意见”(Reaching agreement)，或者简单讲：达成共识。注意，共识不是一个过程，而是一个终止时刻的状态。在人类社会中，这个概念很好理解，它的意思就是所有人都同意一个 _观点_，比如开大会时的全票通过。在计算机科学与分布式系统中，这个概念依然适用，只不过主体不再是人，而是变为了可以执行命令和保存状态的进程(process)，所谓的 _观点_，也变为了可以在计算机中保存的二进制数值。

所以，对于分布式系统来讲，共识就是这样一个状态：所有的进程都记录同一个值，且这个值必然来自于某一个进程。比如说，多个进程都被初始化为相同状态，这不能叫共识。多个进程被初始化为不同状态，后来这些进程不借助任何外部操作变为了相同状态，这叫共识。当然这只是粗略的解释，而且也没有说清楚计算机是怎样完成 _同意_ 这样的行为的，下面让我们把描述修改得略微严谨一些。

让我们来思考一个简单的情形来更好的理解分布式系统中的共识。假设现在有一些人，他们每人都手握一个纸条，纸条上写了一个不可修改的初始整数，每个纸条上的初始值不相同。这个纸条上的内容只能自己看。纸条上还可以写字，但每个纸条只能拿着的人自己写。此外，每个纸条上还有一个额外的写字区域，叫做结果记录区，里面可以写一个整数。任何两个人之间都可以通过直接的对话交换某些信息。这群人最终的**目标是**：_经过多次的信息交换后，每个人手上的纸条里的结果记录区都写着相同的整数，且这个整数是某个人纸条上的初始值_。请问每个人该以怎样的逻辑去交换和记录信息？给出一个算法（这个情形不考虑故障，也不考虑不可靠的通信，只是简单的一群人在交流）。

这个抽象的情景改编自Lamport的论文，感兴趣的读者可以去参考[[1]](#1) [[2]](#2)。这两篇论文比较重要，后续章节还会深入介绍这两篇论文的内容，现在重点先回到上述例子。

上述的情景隐含了一些条件。1)，没有说纸条的大小，所以可以认为纸条上能记录无限多的内容，除了那个结果记录区。2)，一开始结果记录区是空的。3)，结果记录区里的数值一旦写下，将无法被修改。4)，人们通过直接的对话交换信息，意味着一个人说什么另一个人就一定能听到什么。5), 在信息交换的时候，每个人都要处理并记录完上一个人提供的信息后才能和下一个人互动，毕竟人只有一个脑袋两只手，一只手拿纸条一只手拿笔。这也意味着，当两个人同时想和一个人说话时，两个人中必然有一个人要等一下
。6)，每一个人都是独一无二的，比如说他们每个人的身份证号(ID)是不一样的，长相是不一样的等，这样大家都可以准确的认出对方。7), 每个人都知道当前的总人数，该过程不需要互动。

下面将要介绍一种可行的算法。

### 0.1 算法一，找一个确定的人索要数值

上述情景中没有规定记录的整数值必须是多少，但必须是某一张纸条上的初始值。想要达成上述的**目标**，有多种算法可以实现。有一种简单思路是，想办法让所有纸条上结果记录区的值等于身份证号最小的那个人的初始值。算法描述为，对于任何一个人，反复交错执行以下策略：

1. 把自己的身份证号告诉其他所有人，每次只和一个人说。
2. 每次有人告诉自己他的身份证号时，将这个ID记到纸条上，并且将所有已知的ID从小到大排序。
3. 当收集到的身份证号数量（包含自身的）等于人群中的人数时，选取身份证号最小的那个人，并且找那个人问他的纸条上写的什么初始值，最后将值写到自己的结果记录区里面。

这是一个分布式算法。所谓分布式算法，就是指有多个参与者参与并且为了达成目标每个参与者都要执行某种策略的算法。不过，即使是这样一个简单的3条策略，也依然存在许多值得思考的地方。

首先，感兴趣的读者可以思考一下，上述过程中是否会有某个人存在饥饿状态，就是说既找不到有空的人去说自己的身份证号，也没有人把他的身份证号告诉自己？这个问题等价于该算法是否满足 _活性_？后面的章节会再次解释活性(Liveness)。

其次，可以思考一下上述策略1在什么条件下就可以不用执行了？可能有人会以为策略3执行了之后策略1就可以不用执行了，那当然是不对的。其实，策略1停止执行的时间点很明确，就如同这个策略写得那样：成功把自己的身份证号告诉所有人之后，就可以不用再执行了。

第三，策略3中，选择身份证号的时候，不选最小的，而是选倒数第二小的或倒数第三小的，可以不？当然是可以的，只要所有人都遵照这个规约去行动就可以。这个思考也可引申出一个重要的认识，那就是 _“达成统一意见”的前提是每个参与者遵照相同的行为规范_。当然，熟悉拜占庭将军问题的读者此时可能会说这个认识是有问题的，但是现在先不要考虑这个困难情况，后续我会将参与者这个概念进行细化，进而满足其他更复杂的情况。

第四，在策略3中，能否把自己写在结果记录区的值再告诉其他每一个人？这是可以的，这相当于扩展了策略3，而且策略1的终止条件也可以相应的改变，读者可以思考这样做对于“达成统一意见”是加速了还是拖累了，亦或是没有影响？应该是需要分情况讨论。

第五，能否看出上述策略存在两个阶段？对于每一个人，这个算法都是由两个阶段（Two Phases）组成，第一个阶段是收集身份证号，第二个阶段是找那个符合条件的人询问初始值。第一阶段没有完成之前，第二个阶段的操作不会发生。而广播身份证号这一系列操作既不属于第一阶段也不属于第二阶段，它是一个独立的分支，因为它的终止条件不受这两个阶段中任何一个阶段影响。如果把这个算法写成计算机软件，那么广播身份证号这个分支可以在一个独立的线程中完成。读者也可以考虑怎样把这个算法改成严格两阶段的，即任何操作要么属于第一个阶段要么属于第二个阶段？可以借助上面的第四个思考。

第六，这个策略可行的关键是什么？换句话讲，这个算法的Invariant是什么？关于Invariant的介绍，读者可以参考[Loop invariant](https://en.wikipedia.org/wiki/Loop_invariant)。分布式算法中所指的Invariant是一个比Loop invariant更加通用的概念。Invariant声明了算法的不变式，并且暗示了算法的正确性。它可以简单理解为，算法每执行一步，不变式声明的逻辑都为真。在分布式系统中，准确定义与理解Invariant是个困难的事情，直到这几年也依然有顶会论文在讨论[[3]](#3)。上述算法的Invariant可以简单的（非形式化的）描述为：1)，每个人已经记录的身份证号数量小于等于总人数。2)，身份证号最小的那个人是唯一且不变的。

第七，能否直接把这个例子映射到实际的计算机系统中？比如每个人就是一个操作系统进程，它们靠完全可靠的通信链路连接。总节点数是预设值。尝试把以上策略写成伪代码。

第八，这个策略总感觉不够优雅，也就是说没有体现出人们预想的那种“民主”、“自由”的感觉。想要实现这样的效果，就必须要有一种随机性的感觉在里面，即每次从头运行这个算法，最后“达成统一意见”的值都可能不一样。下面给出一种新的策略，它实现了“自由”的感觉，但是效率明显要差一些。

### 0.2 算法二，大家相互竞争，行动最快的人有机会把自己的初始值推给其他人

算法一的经验说明了一个硬性要求，那就是想要让每个人都在结果记录区写上相同的值，前提是所有人都认同这个值的来源。继续算法一的思路，但是不要求预设的选人规则，而是通过一对一的对话确认大家是否认同自己，即可以说：_对结果的共识，前提是对来源的共识_。那么，每个人都可以按照如下策略行动：

1. 依次和每个人交流，告诉他们自己的身份证号。如果对方同意接收，那么记下这个人并且转向下一个人交流。如果不同意，那么忘记之前所有的交流结果，等待一段随机的时间重新开始策略1。
2. 每次有人和自己交流身份证号时，如果自己已经和其他人交流过，那么回复一个“不同意”。否则，就回复一个“同意”，并且不再执行策略1。
3. 如果其他所有人都同意了自己，那么就把自己纸条上写的初始值告诉其他所有人，并且把这个值写到结果记录区。
4. 当收到一个人告诉自己的初始值时，把这个值写到结果记录区。

整个算法分成两个部分。

```
struct Messages {
    int epoch;
    int value;
};
```


### 0.3 我们关心什么

根据算法一和算法二总结的经验，我们可以确定一件事，那就是想要让每个人都在结果记录区写上相同的值，前提是所有人都认同这个值的来源。同时我们又希望每个人都有机会被选中，所以不能像算法一那样预先设定规则。算法二虽然无法完成任务，但是它提供了一些新的思路，即每个人都主动的把信息推给其他人。算法二的问题来源于，别人提供的信息并没有选择性的接受，这导致




## 1. Paxos: Reaching Agreement in the Presence of Faults

首先，我们需要明确一点，那就是我们讨论共识协议的场景是什么。许多早期的学术文献对场景给出了类似如下的抽象，或者说定义：考虑$N$个进程(Process)，其中每个进程都维护了一个私有变量(private value)，


## 2. Raft: 从单槽位共识到多槽位共识



## 3. 总结

很多网上资料对Raft的介绍都是直接从Leader-Follower-Candidate这个状态转换关系讲起，甚至完全不介绍计算机达成共识的原理，本末倒置，这对读者来讲带来了不少理解困难。实际上，Raft中的各种名词叫什么其实无所谓，比如说term这个概念，你要叫它epoch也没问题。只要真正理解了故障环境中的单槽位共识，即基础的Paxos，那么再去理解Raft就容易很多了。而领导者-跟随者-候选人这些状态，也会变得水到渠成。


## 参考文献

<a id="1">[1]</a>
M. Pease, R. Shostak, and L. Lamport, “Reaching Agreement in the Presence of Faults,” J. ACM, vol. 27, no. 2, pp. 228–234, Apr. 1980, doi: 10.1145/322186.322188.

<a id="2">[2]</a>
L. Lamport, “The Part-Time Parliament,” ACM Trans. Comput. Syst., vol. 16, no. 2, pp. 133–169, 1998, doi: 10.1145/279227.279229.

<a id="3">[3]</a>
J. Yao, R. Tao, R. Gu, J. Nieh, S. Jana, and G. Ryan, “DistAI: Data-Driven Automated Invariant Learning for Distributed Protocols,” p. 18, OSDI 2021.

